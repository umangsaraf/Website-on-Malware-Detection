import React from 'react';
import ReactDOM from 'react-dom';
import Button from '@material-ui/core/Button';
import Post from './Post.js'
import PropTypes from 'prop-types';
import {fade, makeStyles} from '@material-ui/core/styles';
import IconButton from '@material-ui/core/IconButton';
import Drawer from "@material-ui/core/Drawer";
import Divider from "@material-ui/core/Divider";
import ChevronRightIcon from "@material-ui/icons/ChevronRight";
import ChevronLeftIcon from "@material-ui/icons/ChevronLeft";
import AppBar from '@material-ui/core/AppBar';
import Toolbar from '@material-ui/core/Toolbar';
import MenuIcon from '@material-ui/icons/Menu';
import CssBaseline from "@material-ui/core/CssBaseline";
import Card from '@material-ui/core/Card';
import CardActions from '@material-ui/core/CardActions';
import CardContent from '@material-ui/core/CardContent';

import { createMuiTheme } from '@material-ui/core/styles';
import {MuiThemeProvider} from "@material-ui/core";
import Paper from '@material-ui/core/Paper';
import Typography from '@material-ui/core/Typography';
import Grid from '@material-ui/core/Grid';
import clsx from "clsx";
import Graph from './react-sigm-changed';

const drawerWidth = 300;

const theme = createMuiTheme({
  palette: {
    primary: { // works
      main: "#212121",
      contrastText: "#1de9b6",
    },
    secondary: { // works
      main: "#17a2bc",
      contrastText: "#1de9b6", //indigo[300]
    },

    third: { // works
      main: "#1de9b6",
      contrastText: "#1de9b6",
    },
  },
  typography:{
    fontSize: 13,
  },
  spacing:4,
});

const useStyles = makeStyles(theme => ({
  grow: {
    flexGrow: 1,
  },
  title: {
    display: 'none',
    [theme.breakpoints.up('sm')]: {
      display: 'block',
    },
  },
  sectionDesktop: {
    display: 'none',
    [theme.breakpoints.up('md')]: {
      display: 'flex',
    },
  },
  sectionMobile: {
    display: 'flex',
    [theme.breakpoints.up('md')]: {
      display: 'none',
    },
  },

  // From PermanentDrawer
  root: {
    display: 'flex'
  },
  appBar: {
    position:'fixed',
    transition: theme.transitions.create(['margin', 'width'], {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
    height: "65px",
  },
  appBarShift: {
    width: `calc(100% - ${drawerWidth}px)`,
    marginLeft: drawerWidth,
    transition: theme.transitions.create(['margin', 'width'], {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen,
    }),
  },

  menuButton: {
    marginRight: theme.spacing(2),
  },
  hide: {
    display: 'none',
  },
  drawer: {
    width: drawerWidth,
    flexShrink: 0,
  },
  // Drawer Setting
  drawerPaper: {
    background:"#424242",
    width: drawerWidth,
  },
  drawerHeader: {
    display: 'flex',
    alignItems: 'center',
    padding: theme.spacing(0, 1),
    ...theme.mixins.toolbar,
  },
  content: {
    flexGrow: 1,
    padding: theme.spacing(3),
    transition: theme.transitions.create('margin', {
      easing: theme.transitions.easing.sharp,
      duration: theme.transitions.duration.leavingScreen,
    }),
  },
  contentShift: {
    transition: theme.transitions.create('margin', {
      easing: theme.transitions.easing.easeOut,
      duration: theme.transitions.duration.enteringScreen,
    }),
    marginLeft: 0,
  },
  Title:{
    fontSize:20,
    fontWeight:600,
    marginLeft:30,
  },
  TitleLink:{
    fontSize:20,
    fontWeight:600,
    marginLeft:30,
    marginTop:20,
  },
  mainFeaturedPost: {
    position: 'relative',
    backgroundColor: theme.palette.grey[800],
    color: theme.palette.common.white,
    marginBottom: theme.spacing(4),
    backgroundImage: 'url(https://source.unsplash.com/random)',
    backgroundSize: 'cover',
    backgroundRepeat: 'no-repeat',
    backgroundPosition: 'center',
  },
  overlay: {
    position: 'absolute',
    top: 0,
    bottom: 0,
    right: 0,
    left: 0,
    backgroundColor: 'rgba(0,0,0,.3)',
  },
  mainFeaturedPostContent: {
    position: 'relative',
    padding: theme.spacing(3),
    [theme.breakpoints.up('md')]: {
      padding: theme.spacing(6),
      paddingRight: 0,
    },
  },
  paper:{
    padding: '5%',
    fontWeight: 400,
  }
}));



  const mainFeaturedPost = {
    title: "Malware Detection",
    image: 'markus-spiske-iar-afB0QQw-unsplash.jpg',
    imgText: 'main image description',
    linkText: 'Continue reading…',
  };


class App extends React.Component{
  constructor(props){

    super(props)

    var nodes = []
    var edges = []

    const url = "test7.json"
    fetch(url)
        .then(resp => resp.json())
        .then(data => {
          /*var edges_to_use = []
          var used_edges = {}
          for(var i = 0; i < data.edges.length; i++){
            if(!used_edges.hasOwnProperty(data.edges[i].source)){
              used_edges[data.edges[i].source] = {}
              used_edges[data.edges[i].source][data.edges[i].target] = 1
              edges_to_use = edges_to_use.concat(data.edges[i])
            }
            else{
              if(!used_edges[data.edges[i].source].hasOwnProperty(data.edges[i].target)){
                used_edges[data.edges[i].source][data.edges[i].target] = 1
                edges_to_use = edges_to_use.concat(data.edges[i])
              }
            }

          }*/
        
          console.log(data)
          //console.log(data.edges.filter(edge_distinct))
          //for(var i = 0; i < data.nodes.length; i++){
          //  data.nodes[i].label = data.nodes[i].id
          //}
          nodes = data.nodes
          edges = data.edges

        })
        .then(data =>{
          this.fetchResult = {
              nodes: nodes,
              edges: edges
            }
          }
        )


        this.classes = useStyles()
        this.open = false

        this.setOpen = this.setOpen.bind(this)
        this.handleDrawerOpen = this.handleDrawerOpen.bind(this)
        this.handleDrawerClose = this.handleDrawerClose.bind(this)
  }
  
  setOpen = (val) => {
    this.open = val
  }


  edge_distinct = (value, index, self) =>{
    //console.log(self)
    //console.log(value)
    //console.log(index)
    for(var l = 0; l < self.length; l++){
        if((value.source === self[l].source) && (value.target === self[l].target)){
            //console.log(index + " " + l)
            return (l === index)
        }
    }
}



  handleDrawerOpen = () => {
    this.setOpen(true);
  };

  handleDrawerClose = () => {
    this.setOpen(false);

  };

  render(){
  return (
    <div>
        <MuiThemeProvider theme={theme}>
        <CssBaseline />
        <AppBar
          id="appbar"
          position="fixed"
          className={this.classes.appBar}
      >
        <Toolbar>
          <IconButton
              color="inherit"
              aria-label="open drawer"
              onClick={this.handleDrawerOpen}
              edge="start"
              className={clsx(this.classes.menuButton, {
                [this.classes.hide]: open,
              })}
          >
            <MenuIcon />
          </IconButton>

          <Typography className={this.classes.Title}>
                 (Title of Malware Paper)
          </Typography>

          </Toolbar>
          </AppBar>

          <Drawer
          className={this.classes.drawer}
          style={{width:drawerWidth}}
          variant="persistent"
          anchor="left"
          color="primary"
          open={open}
          classes={{
            paper: this.classes.drawerPaper,
          }}
      >
          <div className={this.classes.drawerHeader}>
            <IconButton onClick={this.handleDrawerClose}>
              {theme.direction === 'ltr' ? <ChevronLeftIcon /> : <ChevronRightIcon />}
            </IconButton>
            <Typography className={this.classes.Title} style={{color:"#1de9b6"}} color="third">
                 Contents
          </Typography>
          </div>

          <Divider />
          <Divider />

          <Typography className={this.classes.TitleLink} color="secondary">
                 <a href="#intro" style={{color:"#64b5f6", textDecoration:"none"}}> Background</a>
          </Typography>
          <Divider />
          <Typography className={this.classes.TitleLink} color="secondary">
                 <a href="#method" style={{color:"#64b5f6", textDecoration:"none"}}> Methodology</a>
          </Typography>
          <Divider />
          <Typography className={this.classes.TitleLink} color="secondary">
                 <a href="#related" style={{color:"#64b5f6", textDecoration:"none"}}> Related Work</a>
          </Typography>
        </Drawer>


        <Button variant="contained" color="primary">
            ""
        </Button>
        <div style={{margin:20}} ></div>
        <Post post={mainFeaturedPost}></Post>
        <main className={this.classes.content} style={{backgroundColor:"#c5cae9"}}>
          <Paper>
        <Grid container color="primary" style={{marginBottom:20}}>
                <Grid item md={6} color="inherit"> 
                <Card className={this.classes.paper} color="secondary" style={{marginLeft:50, textAlign:"center"}}>

                {(this.fetchResult === null)? <div/> : 
                  <Graph data={this.fetchResult} edgeColor='#e2e2e2'/>
              }
                  How does this explain Hindroid?
                  This is a graph that pairs nodes with high edge weights. So outside malware is not related to opposite malware.
                  Are these the false positives?
                  </Card>
                </Grid>
                <Grid item md={6} color="inherit"> 
                  <Card className={this.classes.paper} color="secondary" style={{marginLeft:50, textAlign:"center"}}>
                    Visual 2
                  </Card>
                </Grid>
          </Grid>
          <Divider />
        <Card className={this.classes.paper} color="secondary">
          <CardContent>

            <Typography paragraph id="intro" color="secondary">
                      Background: 

            </Typography>
            <Typography paragraph color="primary">
            The main overview of our project is to investigate how thorough the classification of
malware is in the Hindroid paper. We will be looking at what Hindroid classifies well and what it
doesn’t classify well. Specifically we will be investigating the true positives, true negatives, false
positives, false negatives as well as the coefficients for the Linear SVM utilized in the HinDroid
paper. This will entail digging into which apps are malware and detected correctly, which apps
aren’t malware and detected correctly, which apps aren’t malware but detected incorrectly, and
which apps are malware and detected incorrectly. These incorrectly detected malware apps are
the most detrimental because an incorrectly detected malware app means that a person could be
downloading an app that could steal their bank information, hold their phone for ransom, or
mangle the software in any number of ways. We will look at malware apps from the Google Play
store similar to the HinDroid paper, investigating the same problem but with the specific model
evaluation metrics in mind. We will be building the same linear SVM discussed in HinDroid but
thoroughy investigating the explainability of such a model utilizing the very easily interpretable
model coefficients. We will be using these coefficients of the linear SVM model to explain the
decisions of the classifier based on weights that are either extremely positive or extremely
negative and look into why certain features have this effect on the classification. This will help
us understand where false positives and false negatives are coming from, which packages or
code blocks are they associated with, and so forth.

            </Typography>
            <Typography>
            The broad problem this will be solving is the reduction of false negatives of the Hindroid
paper. Assuming that the false negatives are the malware apps not being identified, we believe
that the model should prioritize these apps so that harmful malware apps don’t get overlooked.
But more importantly we want to know why these apps aren’t being detected as malware and
which paths through the defined matrices contributed to this. This will involve understanding
where our model goes wrong through investigating the explainability of the model. The domain
replication project is crucial for the development and understanding of how the data and
metapaths are created so that with further investigation we can tell the specific routes from app to
app that are causing the calculation of the coefficients. The metapaths are important for making
connections between benign and malware apps. Just like the HinDroid paper we will establish
connections based on api calls. Whether they are in the same code block, invoked types, and
same api package. This seemed to work well for classifying malware in the Hindroid paper so we
will be using this as our model. So, we will be using the project as the framework and building
from there. Our project is meant to be just an extension or an improvement of the existing
Hindroid project. We will do so by adding coefficients to the complicated relationships, which
can be expressed through the metapaths, in the model. Then, we will be able to fine tune the
weights to reduce false negatives. That is the main difference between our project and the
Hindroid, besides that they’re pretty related. Also, we will be using an SVM kernel similar to the
domain replication project; however, for our purposes, it's also to study the coefficients for the
purposes of model explainability.
            </Typography>
            </CardContent>

        </Card>

        <Grid container color="primary" style={{marginBottom:20}}>
                <Grid item md={6} color="inherit"> 
                  <Card className={this.classes.paper} color="secondary" style={{marginRight:70, textAlign:"center"}}>
                    <CardContent>
                      Figure 3
                      </CardContent>
                  </Card>
                </Grid>
                <Grid item md={6} color="inherit"> 
                  <Card className={this.classes.paper} color="secondary" style={{marginLeft:50, textAlign:"center"}}>
                  <CardContent>
                    Figure 4
                    </CardContent>
                  </Card>
                </Grid>
          </Grid>
          <Divider />
        <Card className={this.classes.paper} color="secondary">
        <CardContent>

            <Typography paragraph id="method" color="secondary">
                      Methodology:
            </Typography>
            <Typography paragraph color="primary">
                     <ol>
                        <li></li>
                        <li></li>
                        <li></li>
                     </ol>
            </Typography>
            </CardContent>

            </Card>
            <Card className={this.classes.paper} color="secondary">
            <CardContent>

            <Typography paragraph id="related" color="secondary">
                      Related Work:
            </Typography>
            <Typography paragraph color="primary">
            In recent years, the paper DREBIN (https://www.sec.cs.tu-bs.de/pubs/2014-ndss.pdf)
suggests an app that detects malware and explains why it classifies an app as malware based on
the weights it assigns. It runs static analysis on many apps and features, including whether they
ask for permission, dangerous API calls, and hardware the app tries to access. Then, it embeds
each of these features into its own vectors, each entry for each app. Using an SVM like us it
feeds in these vectors and rates them. It then analyzes high negative weights to reflect on its
performance. And the MaMaDroid paper (https://arxiv.org/pdf/1612.04433.pdf), an android
detection model that detects based on abstracted api calls (using the package or the source name).
It also contains the sequence of the api calls, not just checking if they’re in the same code block.
Thus, it connects sequential packages/abstract APIs being used between apps. The model itself is
based on Markov chains. On the contrary, detection in Hindroid is based on the connectedness of
apps and APIs and contains a broader set of information to potentially capture more thorough
relationships. Which DREBIN doesn’t do. Therefore, doing model explainability with it would
provide a more in depth look at these relationships and the correct classification of broader types
of malware. For the MaMaDroid paper, it contains complicated relationships different from the
features we’ll be using but the Markov chain uses probabilities and focuses more on app
behavior than connections between apps. We won’t be able to (or at least it’ll be hard) to connect
apps that we know to be malware towards new apps without the use of metapaths. By using
metapaths and weights we assign to them, we can understand the model much easier.
The accuracy of the model and contributions of the Hindroid paper are extensive;
however, understanding the exact types of malware it is good or bad at capturing aren’t explored
thoroughly. By looking into the weights of the SVM and the paths taken by the matrices
corresponding to those feature weights, it will add an additional layer of understanding. We
could add more complicated relationships like the MaMaDroid project but there can be some
issues with that. The MaMaDroid seems to work much better than the Hindroid paper for
training and some test sets but much worse on other test sets. It could be overfitting its model
with relationships not representative of the general malware apps (whether a series of packages
are used in a specific sequence). So although this could be a deficiency in the Hindroid paper, we
might not try to complicate the relationships further. However, similar to the MaMaDroid paper
and unlike the Hindroid paper, we will try to abstract api calls by looking closer at the packages
and their relationships along with the source names. This way we can connect more apps
together and assign many more weights in between them. Thereby we can explain the similarities
and differences between more apps than before, through the weights the SVM will assign.
            </Typography>
            </CardContent>
        </Card>
        </Paper>
        </main>

        </MuiThemeProvider>
    </div>
  );
}
}




//each are classes
//Classes:
    //.mainFeaturedPost
    //.overlay
    //.mainFreaturedPostContent


ReactDOM.render(<App />, document.getElementById('app'));